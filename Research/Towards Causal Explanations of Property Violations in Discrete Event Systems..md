#to-read 

discrete event systems (DES)
# Preliminaries
---

Synchronization operation on automata based on **shared events**. 
- When two automata share an event, this event must occur simultaneously in both. 
- The other events occur asynchronously, which means that they only occur in their respective automaton.
### Synchronization
--- 
The synchronization of two automata $A_i = (S_i, \Sigma_i, \delta_i, F_i, s_{0i})$, $i = 1, 2$, is the automaton:
$$
A_1 \parallel A_2 = \{ S_1 \times S_2, \Sigma_1 \cup \Sigma_2, \delta, F_1 \times F_2, (s_{01}, s_{02}) \}
$$
where:
$$
((s_1, s_2), e, (s_1', s_2')) \in \delta \iff
\begin{cases}
    (e \in \Sigma_1 \cap \Sigma_2) \land (s_1, e, s_1') \in \delta_1 \land (s_2, e, s_2') \in \delta_2 \\
    \lor (e \in \Sigma_1 \setminus \Sigma_2) \land (s_1, e, s_1') \in \delta_1 \land s_2' = s_2 \\
    \lor (e \in \Sigma_2 \setminus \Sigma_1) \land (s_2, e, s_2') \in \delta_2 \land s_1' = s_1
\end{cases}
$$

# Problem Statement
---

We consider that a behavioral model of the system is available and is represented as a deterministic automaton $A = (S, \Sigma, \delta, F, s_0)$. This automaton can be **monolithic** or can result from a **multi-component model**, in which case the system is modeled by a set of interacting automata. This interaction is defined by the synchronization of the common events of each automaton $A = A_1 \parallel \dots \parallel A_n$. 
- The system has a **prefix-closed behavioral description**. That means that every prefix of behavior respecting the behavioral description also respects the behavioral description, so $S = F$.
- The set of events is partitioned into the set of **observable events** $\Sigma_o$ and the set of **unobservable events** $\Sigma_{uo}$. We make the assumption that there are no unobservable cycles possible in $A$, in other words, we assume that the number of unobservable events that can be generated by the system between any two observable events is bounded.

> [!important] Log
> Any execution of the system can be associated with a **log** $L \subseteq \Sigma_o^*$ that is ==a finite sequence of observable events.== As the system is partially observable, a log $L$ can be associated with **several possible traces** (these are the traces that are consistent with the **log** $L$).
> Formally, the set of traces consistent with the **log** $L$ is given by:
> $$
> tr(L) = \{ t \in \Sigma^* \mid \Pi_{\Sigma_o}(t) = L \} \cap T(A)
> $$
> 
> The log $L$ can be represented as an automaton $\mathcal{L} := ex(L)$ such that $T(\mathcal{L}) = \{ L \}$. An example is the log $a \cdot a \cdot br \cdot a \cdot cr \cdot br$. (similar to path automata of a hybrid automata)

![[Pasted image 20240912120350.png]]

> [!important] Safety Property
> A **safety property** is respected by the system as long as the current execution leads to a state where the property is satisfied. If the execution of the system leads to a state that does not satisfy the property, then we say that the property is violated. 

-  The violation of a safety property is **permanent**, i.e., **all continuations of an execution** violating the safety property also violate the property. Such a property can be defined as a **prefix-closed event language** over $\Sigma$ such that, if the execution of the system generates a prefix of this language, it leads to a state that satisfies the property.

> [!important] Observer
> In the following, we denote by $\mathcal{P}$ an **observer** of the violation of the property. ==The observer $\mathcal{P}$ is a **complete automaton associated with the safety property** that accepts as language only the traces of the executions violating the safety property.==

We can now formally represent as an automaton:

> [!important] 
> 1. The set of executions of the system that violate the safety property: $A \parallel \mathcal{P}$;
> 2. The set of executions of the system that are consistent with a given log $L$: $A \parallel L$;
> 3. The set of executions of the system that violate the safety property and that are consistent with a given log $L$: $A \parallel \mathcal{P} \parallel L$.
> 

- The synchronization, being an associative operation, $A \parallel \mathcal{P} \parallel L$ is perfectly defined as $(A \parallel \mathcal{P}) \parallel L = A \parallel (\mathcal{P} \parallel L)$.

	A state of $A \parallel \mathcal{P} \parallel L$ is a tuple $(s_A, s_{\mathcal{P}}, s_L)$ where $s_A$, $s_{\mathcal{P}}$, and $s_L$ are the respective states in $A$, $\mathcal{P}$, and $L$. We use the notation $(s_A, s_{\mathcal{P}}, s_L) \parallel \mathcal{P} = (s_A, s_{\mathcal{P}})$ to pick the state in $A \parallel \mathcal{P}$ associated with a state in $A \parallel \mathcal{P} \parallel L$. Thanks to this association, in the rest of the paper, we implicitly extend the functions defined on the states of $A \parallel \mathcal{P}$ on the states of $A \parallel \mathcal{P} \parallel L$.

# Effective Choice Explanation
---


We first define the notion of level of choice, which is a special case of the *fate and free will layers* of [[Fate and free will in error traces]] in the case where the set of environment variables is empty. The notion of choice state corresponds to the boundaries of layers i > 0.

### Levels of Choice
___
==The number of choice that has to be made in different states to violate a particular safety property. ==

Let $\xi : S \to \mathbb{N} \cup \{\infty\}$.

We say that $\xi$ is a level of choice in the automaton $A \parallel P = (S, \Sigma, \delta, S_0, F)$ if:

1. $\forall s \in F$, $\xi(s) = 0$.

2. $\forall s \in S$ such that $s$ is not co-reachable, $\xi(s) = \infty$.

3. $\forall s \in S \setminus F$, if $s^* \neq \emptyset$ and $\exists i \in \mathbb{N} \cup \{\infty\}$, $\{ \xi(s') \mid s' \in s^* \} = \{i\}$, then $\xi(s) = i$. Those states are called **non-choice states**. (uniform level of choice)

4. $\forall s \in S \setminus F$, if $s^* \neq \emptyset$ and $\{ \xi(s') \mid s' \in s^* \} > 1$, then $\xi(s) = 1 + \min_{s' \in s^*}(\xi(s'))$. Those states are called **choice states**. (non uniform level of choice)

5. **Maximality**: $\xi$ is maximal among the functions fulfilling the preceding conditions.

The executions of the [[#behavioral model]] $A$ violating the safety property end in an accepting state, i.e., in a state of $F$.

>[!note] Conditions of levels of choice
>- The first condition of requires that the level of choice of **accepting states** is $0$, 
>  meaning that no choice has to be made in those states to violate the safety property because the violation has already happened.
>  - The second condition requires the level of choice of the states that are **not co-reachable**(no path between them) to be $\infty$; this means that in those states, no choice can be made to reach a violation.
>  - The third condition requires that, given a state $s$, if the level of choice of the successors is uniform (level of choice of all successor states is same), then the level of choice of $s$ is the same as its successors. Those states are qualified as **non-choice states** because the decision about the outgoing transition does not impact the level of choice.
>  - The fourth condition requires that, given a state $s$, if the level of choice of the successors is not uniform, then the level of choice is equal to the increment by one of the lowest level of choice in the postset $s^*$. 
>    **Choice states** are the counterpart of non-choice states. When the decision about the outgoing transition impacts the level of choice,** this decision can be made so as to decrease the level of choice**. When in a state, it is possible to decrease the level of choice by choosing a transition, it is also possible to increase the level of choice by $0$ or more.
> - The last condition is required because we do not want infinite executions with a finite number of choice states.

### Effective Choice Transitions
---

> [!important] Effective Choice Transitions
> Given $A \parallel \mathcal{P} \parallel \mathcal{L}^c = A_{\parallel\parallel}$, 
> a transition $s \xrightarrow{e} s'$ of an accepting execution $\rho$ of $A_{\parallel\parallel}$ is an **effective choice transition** if:
> $$
> \forall s'', e, \rho, s < s'' \implies \xi(s'') < \xi(s)
> $$
> ==where $s < s''$ means that the state $s$ occurs before the state $s''$ in the execution $\rho$.==
> 
> Let $\delta_c(A_{\parallel\parallel})$ be the set of **effective choice transitions** for some accepting execution of $A_{\parallel\parallel}$.
> 
> The **effective choice transitions** sum up the violation in the case of a unique execution. 
> 
> - They point at the **erroneous actions** that are **not compensated** by some subsequent actions. 
> 

We also want to provide the human operator with a concise representation of alternative safe executions. This is done by defining **safe alternatives**.

References
---
G. Gössler, T. Mari, Y. Pencolé, and L. Travé-Massuyès. Towards Causal Explanations of
Property Violations in Discrete Event Systems. In DX’19 - 30th International Workshop on
Principles of Diagnosis, pages 1–8, November 2019.