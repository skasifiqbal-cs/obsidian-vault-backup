
# Contents/Abstract
---

- explaining faults in [[real-time systems]]
- ==explanation of violation of safety property - is a concise excerpt of the faulty execution that retains only the elements that were relevant for entailing the violation==
- formal definition of causal explanations on [[dense-time models]]
- based on [[timed automata]] and [[zone-based abstractions]]
- accounts for limited [[observability]] of faulty execution
- symbolic formalization to construct such explanation

# Introduction
---

- software engineering, formal verification, and certification of embedded systems.

- **Complementary Approach**  -  [[Accountability]] aims at constructing systems in such a way that the responsibilities for a failure can be identified and explained post mortem.

-  **Challenges for formalizing the objective of explanation in embedded systems:**
	1. *Conveying the right amount of information* ( for helping a human expert in quickly understanding the causes of the violation // for automatically reacting to the failure by swapping a component or changing parameters)
	2. *Devising explanation that satisfy the requirements (challenges) of the embedded systems* 
		1. Infinite state space -  requires **abstraction** but [[reasoning about causation on abstractions ]]is not a very explored area.
		2. Limited observability of state and events of embedded systems

- Contributions of the paper
	1. How to construct a ==safety property ==and an ==execution log== that violates the property, a  ==explanation of how the log brought about the violation== of the the property.
	2. Formal definition of causal explanations on dense-time models.
	3. Symbolic approach to effectively construct explanations.

# Related Works
---

- **Causal Explanations**(==Closest to this papers approach==) -  Construction based on effective choice [[explanation for discrete event systems.]] which leverages game theory to explain counter example traces from  model checking.
	- Other approaches based on ==subsequences of traces== -[[ explanatory diagnosis]] and [[causal compression]] ==but these don't convey any information about the outcomes generated by alternative branches in a non deterministic systems.==
	- Other approaches on [[static program slicing]] determine a part of a program that influences a set of variables at a given point.  [[Dynamic slicing]] computes a slice( part of a program) yielding a smaller slice. ==But, our approach accounts for counterfactual runs that have not been taken in the actual execution.==
- ** Fault diagnosis, localization and repair** - Counterfactual causation a precise assessment of individual causes that contribute to bring about an effect,  e.g. [[definition of  actual causality]]
	- Most related works are based on  some form of model to compare the actual execution with counterfactual traces, but techniques under explainable AI lack a model and hence possibility of counterfactual reasoning. [[causal revolution J Pearl]]

# Preliminaries
---

### Clock

- Let $C$ be a set of clock variables $(c, c')$ that take values in $\mathbb{R}^{+}$. 
- A **$C$-valuation** is a function: $C \to \mathbb{R}^{+}$
 - Let **$0$** denote the $C$-valuation assigning $0$ to all clocks.

- An atomic constraint on $C$ is an inequality of the form:
$$
c \sim k \quad \text{or} \quad c - c' \sim k
$$
	where $c, c' \in C$, $\sim \in \{ \leq, <, \geq, > \}$, and $k \in \mathbb{N}$.

- We say that a $C$-valuation $v$ satisfies an atomic constraint $c \sim k$ (or $c - c' \sim k$) if:
$$
v(c) \sim k \quad \text{(or)} \quad v(c) - v(c') \sim k
$$

---

- A $C$-constraint is a ==finite conjunction== of atomic constraints on $C$.
- Let $\mathbb{C}$ denote the ==set of $C$-constraints==. By abuse of notation, we use a $C$-constraint interchangeably with the sets of $C$-valuations that satisfy it.

---

### [[timed automata]]

(Timed Automaton). A timed automaton (TA) $A$ is a tuple 
$$
A = \langle \Sigma, L, L_0, C, F, \mathcal{I}, E \rangle
$$
where:
- $\Sigma$ is a finite set of events;(not in our definition of HA *check in the paper of Timed Automata*)
- $L$ is a finite set of locations;
- $L_0 \subseteq L$ is the set of initial locations;
- $C$ is a set of clock variables;
- $F \subseteq L$ is a set of accepting locations;
- $\mathcal{I} : L \to \mathbb{C}$ specifies for each location an invariant (function from location to the set of C-constraints);

> [!important] Edge $E \subseteq L \times C \times \Sigma \times 2^C \times L$ is a set of edges of the form
> $$
e = \langle \ell, g, \sigma, X, \ell' \rangle
$$

where $\ell$ and $\ell'$ are respectively source and target locations; $\sigma$ is an event; $g$ is the guard of $e$; and 

==X is a set of clocks to be reset when the edge is traversed.== ($2^C$ sets possible for X, is the number of  power set of  $C$)

- Because certain events are not observable, the set $\Sigma$ of events is partitioned into **observable** and **unobservable** subsets.


---

### LTS

- ==Formalize the semantics of timed automata== using labelled transition systems or  LTS
  ( ==It is essentially same as the transition table of a Turing machine *verify*==)

An LTS is a tuple | LTS essentially describes the discrete behavior

> [!important] LTS
> $$
> \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle
> $$
> where 
> * $\Sigma$ is the alphabet,
> * $\mathcal{V}$ is a set of nodes, 
> * $\mathcal{E} \subseteq \mathcal{V} \times \Sigma \times \mathcal{V}$ is the set of labeled transitions, and 
> * $\mathcal{V}^0 \subseteq \mathcal{V}$ and $\mathcal{V}^F \subseteq \mathcal{V}$ are the sets of initial and accepting nodes, respectively.

For $\nu \in \mathcal{V}$, 
- let $\nu^{\bullet} = \{ \nu' \in \mathcal{V} \mid \exists \sigma \in \Sigma : (\nu, \sigma, \nu') \in \mathcal{E} \}$ be the postset of $\nu$. ( set of all v' i.e. the target node/vertex while v is the source vertex)

In the following, we use the terms LTS and graph interchangeably.


###  Semantic LTS

The semantic LTS of a timed automaton $\mathcal{A} = \langle \Sigma, L, L_0, C, F, \mathcal{I}, E \rangle$ is the LTS
$$
\text{sem}(\mathcal{A}) = \langle \Sigma', \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle
$$
where:

- $\Sigma' = \Sigma \cup \mathbb{R}^{+}$ is the set of labels (introduces labels for time spent)
  (different sets possible for different valuation of clock variables whose values are in $\mathbb{R^+}$);
- $\mathcal{V} = \{ (\ell, v) \mid \ell \in L \wedge v \in \mathcal{I}(\ell) \}$, i.e., the states of $A$ are the pairs $(\ell, v)$ where ==$v \in \mathcal{I}(\ell)$ is a clock valuation that satisfies the invariant of the location== $\ell$;     |     Just like states of hybrid automata, location and variable valuation make up a state;
- ==$\mathcal{V}^0 = \{ (\ell, v) \in \mathcal{V} \mid \ell \in L_0 \wedge v = 0 \}$;
  $v$ ==clock valuation should be a tuple, or does $v$ = **0** means all clock set to 0? --> ==**0** is the C-valuation assigning 0 to all clocks also v is a valuation function which requires clock variables as input==
- $\mathcal{V}^F = \mathcal{V}$ (indeed, the accepting states do not matter);
- The set of transitions consists of two types, discrete and time transitions:

$$
  \mathcal{E} = \{ ((\ell, v), \sigma, (\ell', v')) \mid \exists g, X : \langle \ell, g, \sigma, X, \ell' \rangle \in E \wedge v' = v[X := 0] \wedge v' \in \mathcal{I}(\ell') \}
   $$
$$ 
  \cup \{ ((\ell, v), \delta, (\ell, v')) \mid \delta > 0 \wedge v' = v + \delta \wedge v' \in \mathcal{I}(\ell) \}
$$
> [!NOTE] Discrete Transition $(\sigma)$
>      
>   - there must exist guard g and reset map X so that the tuple (l,g, ...) belongs to the edge
>   - The reset map assigns the clocks in set X to 0 
>   - The clock valuation should satisfy the invariants of the target location. 
 
> [!NOTE] Timed Transition $(\delta)$
> $\delta$ probably refers to the time spent in a location $l$, $\delta \in \mathbb{R^+}$
> - time spent should be positive
> - because the rate of evolution of clocks is 1, so the change in **all clock values** is $\delta$ which is given as $v' = v + \delta$
> - the updated clock values should satisfy the invariant conditions of location $l$.



The states $(\ell', v')$ and $(\ell, v')$ are respectively called $e$-successor and $\delta$-successor of $(\ell, v)$.

- As usual, we write $(\ell, v) \xrightarrow{\sigma} (\ell', v')$ for $((\ell, v), \sigma, (\ell', v')) \in \mathcal{E}$. By abuse of notation, we omit the curly braces in $\{\mathcal{V}^0\}$ when there is a single initial state. 

> [!important] $\delta$ property
> - Note that since $\delta$ is a real number, a time transition $(\ell, v) \xrightarrow{\delta} (\ell, v')$ can be split into an arbitrary number $k$ of time transitions, that is,
> $$
> (\ell, v) \xrightarrow{\delta_1} (\ell, v_1) \xrightarrow{\delta_2} (\ell, v_2) \cdots \xrightarrow{\delta_k} (\ell, v_k)
> $$
> such that $\delta = \delta_1 + \delta_2 + \cdots + \delta_k$.


---

### Runs

Let $G = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$ be an LTS.

- A **run** of $G$ starting from $\nu_1 \in \mathcal{V}$ is a ==(finite or infinite) sequence of states and transitions:==
  $$
  \rho = \nu_1 \xrightarrow{e_1} \nu_2 \xrightarrow{e_2} \cdots
  $$

> [!important]
> -   We denote by $\Upsilon(G)$ the set of all runs of $G$. 
> - A state $\nu$ is **reachable** if there is a run from an initial state to $\nu$.
> 

> [!important] Trace
> - Given a run $\rho \in \Upsilon(G)$, the sequence of labels(**events**) in $\rho$ is called a **trace**. We denote by $\Psi(G)$ the set of all traces of $G$.


___

### Timed Log

- Log L - Finite sequence of observable events.
- A timed log is a **one-clock, deterministic, and acyclic** TA.    |    Deterministic because there are no branches?
- In addition, ==all the events of the automaton ==are [[observable]].

An example of **timed log is a timed automaton** roughly depicted as follows: 

> [!example] Timed log
> $$
> l_0 \xrightarrow{x=t_0, a, \emptyset} l_1 \xrightarrow{x=t_1, b, \emptyset} l_2 \xrightarrow{x=t_2, a, \emptyset} l_3
> $$
> - with $l_3$ as an accepting location and $l_0$ an initial location. 
> - The edge from the location $l_0$ to the location $l_1$ has the guard $x = t_0$;
> - its event is $a$ (observable); 
> - and its set of clocks to be reset is empty $\phi$.


---


### Safety Property Observer

- Timed automaton with **one sink state**, to model the **property violation of a timed log**.
- Observer has to **receptive over** all ==observable events== in $\mathcal{A}$ ( i.e. $\Sigma_1$ from the receptive definition is the subset containing observable events)

### Receptive

An LTS $\langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$ is **receptive** over $\Sigma_1 \subseteq \Sigma$ 

> [!important] receptive
> - if at every reachable state $\nu$, all events in $\Sigma_1$ are enabled, that is:
$$
\forall \sigma \in \Sigma_1 \ \exists \nu' : \nu \xrightarrow{\sigma} \nu'.
$$

Given a [[#Timed Log]] $\mathcal{L}$ and a [[#Safety Property Observer]] $\mathcal{P}$, we say that $\mathcal{L}$ violates the safety property at hand if each run of $\mathcal{L}$ is a run of $\mathcal{P}$ that reaches the sink state.

in other words
 
> [!NOTE] violation of safety property
> - given a single clock, deterministic, acyclic TA by $\mathcal{L}$ where all events of the automaton are observable and
> - another TA $\mathcal{P}$ with one sink state where all reachable states have observable events(receptive over observable events)
>
if each [[#Runs]] in $\mathcal{L}$  is a run in $\mathcal{P}$  that reaches the sink state


---

- The set of states of timed automaton is infinite, so a finite abstraction is used to generate explanations.
- This work uses [timed-abstracting bisimulations]] to abstract away time lapses
- leading to finite discrete abstractions of the TA, from which we can compute [[choice based explanations]]

### Strong Bisimulations

A binary relation $\sim$ on an LTS $G = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$ is a **strong bisimulation** 
if for any pair of nodes $p$ and $q$ of $G$ such that $p \sim q$, the following conditions hold:

> [!important] Strong bisimulation conditions
> - $\forall \sigma \in \Sigma \ \forall p' \in \mathcal{V} : (p \xrightarrow{\sigma} p' \implies \exists q' : q \xrightarrow{\sigma} q' \wedge p' \sim q')$;
>   
> - The above condition also holds when $p$ and $q$ are swapped (symmetric - hence bisimulations);
> 
> - $p \in \mathcal{V}^F \iff q \in \mathcal{V}^F$.


> **Strong bisimilarity** (or strong bisimulation equivalence) relates **two LTSs** in the following way: 
> if one LTS can perform an action $a$, then the other LTS must also be able to perform an $a$ action, and in such a way that the resulting states are again related. This relation works both ways simultaneously (which is suggested by the "bi-" prefix in the name of the equivalence).

> [!NOTE] Simulations
> - A relation $R$ on the states of an LTS is called a **simulation** if for any states $s, s', t$ and action $a$, if $s \xrightarrow{a} s'$ and $s \ R \ t$, then there exists a state $t'$ such that $t \xrightarrow{a} t'$ and $s' \ R \ t'$.

> [!NOTE] Bisimulation
> - A symmetric simulation is called a **bisimulation**.

- Two states $s$ and $t$ are called **strongly bisimilar** (or **strongly bisimulation equivalent**) iff there exists a bisimulation $R$ such that $s \ R \ t$.

- Given two LTSs $T = (S, A, \xrightarrow{}, s_0)$ and $T' = (S', A', \xrightarrow{}, s'_0)$, we say that $T$ and $T'$ are strongly bisimilar iff $s_0$ and $s'_0$ are strongly bisimilar. (initial states are bisimilar)

#insert-examples
		![[bisimilarity.png]]
- The second model simulates the first but the first cannot simulate the second. Hence not bisimilar.

When $G$ is the semantic LTS of a TA, 
the relation $\sim$ is a **strong time-abstracting bisimulation (STAB)** 

> [!important] STAB
> if for any pair of nodes $p = \langle \ell_1, v_1 \rangle$ and $q = \langle \ell_2, v_2 \rangle$ of $G$ such that $p \sim q$, the following conditions hold:
> 
> 1. $\ell_1 = \ell_2$; 
> 
> 2. $\forall \sigma \in \Sigma \setminus \mathbb{R}^{+} \ \forall p' \in \mathcal{V} : (p \xrightarrow{\sigma} p' \implies \exists q' : q \xrightarrow{\sigma} q' \wedge p' \sim q')$; 
>    
> 3. $\forall \delta > 0 \ \forall p' \in \mathcal{V} : (p \xrightarrow{\delta} p' \implies \exists \delta' > 0 \ \exists q' : q \xrightarrow{\delta'} q' \wedge p' \sim q')$;
> 
> 4. The above conditions also hold when $p$ and $q$ are swapped;
> 
> 5. $p \in \mathcal{V}^F \iff q \in \mathcal{V}^F$.

>[!NOTE]
> if for any pair of nodes $p = \langle \ell_1, v_1 \rangle$ and $q = \langle \ell_2, v_2 \rangle$ of $G$ such that $p \sim q$, the following conditions hold:
> 
> 1. We are trying to abstract the states due to the different values of the clock with time. So we look for the states within a location, hence $\ell_1 = \ell_2$;  ; 
> 
> 2. $\forall \sigma \in \Sigma \setminus \mathbb{R}^{+} \ \forall p' \in \mathcal{V} : (p \xrightarrow{\sigma} p' \implies \exists q' : q \xrightarrow{\sigma} q' \wedge p' \sim q')$; 
>   (Establishes the equivalence among all the states in a location, due to variable value difference. It checks whether all states take same actions and moves to states that are also equivalent by making $\sigma$  transitions)
> 
> 3. $\forall \delta > 0 \ \forall p' \in \mathcal{V} : (p \xrightarrow{\delta} p' \implies \exists \delta' > 0 \ \exists q' : q \xrightarrow{\delta'} q' \wedge p' \sim q')$;
>    (These p' and q' are different from the p' and q' of the second step)
> 
> 4. The above conditions also hold when $p$ and $q$ are swapped;
> 
> 5. $p \in \mathcal{V}^F \iff q \in \mathcal{V}^F$.


# Explanations
---

- How the violation came to happen for the TA, A, an observer P and a timed log that violates P.
- Main focus on **non-deterministic choices in the execution that entailed the failure**, where **different choices would have helped to avoid it.**
Use the [[Towards Causal Explanations of Property Violations in Discrete Event Systems.#Effective Choice Explanation|Effective Choice Explanation]] to timed automata.

![[Pasted image 20240912130147.png]]

The main steps of construction is as follows:

1. Construct a timed [[#Log observer]] $\mathcal{L}^c$ from $\mathcal{L}$ that tracks, for any run $\rho$ of $\mathcal{L}^c$, whether the observable behavior of $\rho$ produces $\mathcal{L}$.

2. Compose $A$, $\mathcal{P}$, and $\mathcal{L}^c$ to form a timed automaton $A \parallel \mathcal{P} \parallel \mathcal{L}^c$, where $\parallel$ is the standard parallel composition of timed automata, see e.g. [23]. 
   (The set of executions of the system that violate the safety property and that are consistent with a given log $\mathcal{L^c}$: $A \parallel \mathcal{P} \parallel \mathcal{L^c}$.)

3. Construct a discrete abstraction $[A \parallel \mathcal{P} \parallel \mathcal{L}^c]$ of the continuous-time semantics of $A \parallel \mathcal{P} \parallel \mathcal{L}^c$, using a time-abstracting bisimulation.

4. Compute the **levels of choice** on $[A \parallel \mathcal{P} \parallel \mathcal{L}^c]$ that, intuitively, represent, for each equivalence class $q \in [A \parallel \mathcal{P} \parallel \mathcal{L}^c]$, the number of bad choices $\xi(q)$ left before violating $\mathcal{P}$.

5. Extract, from $[A \parallel \mathcal{P} \parallel \mathcal{L}^c]$, a sequence of subgraphs $G_i$ representing the traces that will be condensed to an explanation of length $i$.

6. Abstract away, from each $G_i$, all transitions that do not decrease $\xi$, in order to obtain the explanation $\mathcal{E}_i$ that retains only those (discrete or timed) transitions that contributed to the failure.

### Log observer

Given an alphabet $\Sigma$ and a timed log $\mathcal{L}$ over the observable alphabet $\Sigma^{obs} \subseteq \Sigma$, we construct a **log observer** that ==accepts all runs over $\Sigma$== and ==enters an accepting **sink** state whenever an observed behavior is inconsistent with the [[#Timed Log|log]].==
(when the guard of the transition from l to l' is not satisfied in the log) 

(Observed behaviour is the final result, which is checked among the events  in the log | How can an observed behaviour be inconsistent with the log =  **Maybe when the guard of a transition for a location can never be satisfied**)

> [!important] Log Observer
> The observer of a log $\mathcal{L} = \langle \Sigma, L, L_0, C, F, \mathcal{I}, E \rangle$ is the TA $\mathcal{L}^c := \langle \Sigma, L', L_0, C, F, \mathcal{I}, E' \rangle$ where:
> - $L' = L \cup \{ \text{sink} \}$ where $\text{sink} \notin L$ is a fresh location;
> 
> - $\mathcal{I'} = \mathcal{I} \cup \{ \text{sink} \mapsto \text{true} \}$;
> 	(Invariant condition for staying in sink location)
> 
> - $E' = E \cup E_1 \cup E_2$ where:
>   1. $E_1 = \{ (\ell \xrightarrow{C(\ell, \sigma), \sigma, \emptyset} \text{sink}) \mid \ell \in L \land \sigma \in \Sigma \}$, where $C(\ell, \sigma) = \neg \lor \{g \mid \exists \ell' \in L : \ell \xrightarrow{g, \sigma, \cdot} \ell' \}$
> 	  (The guard condition for moving to sink locations depends on the guard condition for moving to all location $l'$, it being true when all these guard conditions are false)
>   2. $E_2 = \{ (\text{sink} \xrightarrow{\text{true}, \sigma, \emptyset} \text{sink}) \mid \sigma \in \Sigma \}$.
> 

Intuitively, $E_1$ is the set of edges from a location in $\mathcal{L}$ that are not consistent with $\mathcal{L}$, used to make the log observer [[#Receptive|receptive]] with respect to $\Sigma^{obs}$. (Without $E_1$ the transitions whose guard wasn't satisfied would not be taken thus all the observable events would not be enabled)

### Discrete Abstraction
---

To obtain discrete abstractions for the timed automaton $A \parallel \mathcal{P} \parallel \mathcal{L}^c$, we use the STaB. 
Given a TA over alphabet $\Sigma$ with semantic LTS $G = \langle \Sigma \cup \mathbb{R}^+, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$ and a partition $\widetilde{\mathcal{V}}$ (The exact grouping with information about which vertices are grouped) of $\mathcal{V}$, 

> [!important] [[Analysis of timed systems using time-abstracting bisimulations#Time Abstracting Quotient Graph|Quotient]] of with STaB
> the **quotient** of $G$ ( the graph obtained after grouping the elements) with respect to $\widetilde{\mathcal{V}}$ is the 
> LTS $G/\widetilde{\mathcal{V}} = \langle \Sigma', \widetilde{\mathcal{V}}, \mathcal{E}', \widetilde{\mathcal{V}}^0, \widetilde{\mathcal{V}}^F \rangle$ where:
> 
> - $\Sigma' = \Sigma \cup \{\delta\}$ where $\delta$ is a fresh symbol;
> - $\mathcal{E}' = \{\widetilde{\nu} \xrightarrow{\sigma} \widetilde{\nu'} \mid (\nu, \sigma, \nu') \in \mathcal{E} \land \sigma \in \Sigma \} \cup \{\widetilde{\nu} \xrightarrow{\delta} \widetilde{\nu'} \mid \exists t > 0 : (\nu, t, \nu') \in \mathcal{E} \}$;
> - $\widetilde{\mathcal{V}}^0 = \{\widetilde{\nu} \mid \nu \in \mathcal{V}^0\}$ and $\widetilde{\mathcal{V}}^F = \{\widetilde{\nu} \mid \nu \in \mathcal{V}^F\}$.
> 
> And for $\nu \in \mathcal{V}$, $\widetilde{\nu}$ denotes the element of $\widetilde{\mathcal{V}}$ for which $\nu \in \widetilde{\nu}$.

In particular, we are interested in the quotient with respect to the **equivalence classes of states**, called **symbolic states**, induced by STaB. Let $[A \parallel \mathcal{P} \parallel \mathcal{L}^c] := A \parallel \mathcal{P} \parallel \mathcal{L}^c / \sim$ be the quotient graph with respect to STaB. 
This quotient graph can be computed by the existing timed automata model-checkers, such as **UPPAAL** and **Kronos** . In this work, we use the tool **Minim** integrated in Kronos.


### Levels of choice
---

In the following, we compute the level of choice on $[A \parallel \mathcal{P} \parallel \mathcal{L}^c]$. Intuitively, the level of choice measures how close the system is to violating the required safety property.
==(how many bad choice to make in order to reach the sink state )==

> [!important] [[Towards Causal Explanations of Property Violations in Discrete Event Systems.#Levels of Choice|Level of choice]]
> Given an LTS $G = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$, we say that $\xi : \mathcal{V} \to \mathbb{N} \cup \{\infty\}$ is the level of choice function if:
> 
> 1. $\forall \nu \in \mathcal{V}^F : \xi(\nu) = 0$
> 
> 2. $\forall \nu \in \mathcal{V}$ such that $\nu$ is not co-reachable, $\xi(\nu) = \infty$
> 
> 3. For all other states $\nu \in \mathcal{V}$, let:
> $$
> \xi(\nu) = \min^+\left(\left\{ \ell \mid \exists \nu' : \xi(\nu') = \ell \land \exists e \in \Sigma : \nu \xrightarrow{e} \nu' \right\}\right)
> $$
> (in case of non uniform levels of choice due to different events, take the minimum value among all '+1' because one decision has to be made in choosing the event with lowest level of choice and when there is no choice or there is only a single transition and thus it is uniform level)
> where
> $$
> \min^+(G) = 
> \begin{cases}
> \min(G) & \text{if } |G| \leq 1 \\
> 1 + \min(G) & \text{otherwise}
> \end{cases}
> $$
> and we set $\min \emptyset = \infty$. (When the node has no successors  or no outgoing transition e.g. - the s_infinity and final state)
> 
> 4. **Maximality**: $\xi$ is maximal among the functions fulfilling the preceding conditions.


### [[Towards Causal Explanations of Property Violations in Discrete Event Systems.#Effective Choice Transitions|Effective choice]]
---

> [!important] Effective Choice
> Given an LTS $G = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$ and a level of choice function $\xi : \mathcal{V} \to \mathbb{N} \cup \{\infty\}$, a transition $s \xrightarrow{e} s' \in \mathcal{E}$ is an **effective choice transition** iff:
> $$
> \xi(s) = 1 + \xi(s') \text{ and } \exists \rho = s' \xrightarrow{e_0} s_1 \xrightarrow{e_1} ... s_n \in run(G) \\ 
> \text{ such that } \xi(s_n) = 0 \
> \text{and} \left ( \max_{s \in \rho} \xi(s) \right) = \xi(s').
> $$
> When such a transition exists, the state $s$ is called an **effective choice transition**.
> 

Intuitively, an **effective choice transition** is a transition that decrements the level of choice and is a prefix of a run $\rho$ violating $\mathcal{P}$ along which the level of choice no longer exceeds $\xi(s')$.

> [!important] Lemma
> 
> Let $G = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$ and $\xi$ the level of choice of $G$. 
> Let $\mathcal{V}^C = \{ \nu \in \mathcal{V} \mid \xi(\nu) \in \mathbb{N} \setminus \{0\} \land \xi(\nu) = 1 + \min \{\xi(\nu') \mid \nu' \in \nu^{\bullet} \} \}$ and $\mathcal{V}^{NC} = \{ \nu \in \mathcal{V} \mid \xi(\nu) \in \mathbb{N} \setminus \{0\} \} \setminus \mathcal{V}^C$. Then:
> $$
> \mathcal{E} \cap (\mathcal{V}^{NC} \times \Sigma \times \mathcal{V}^{NC})
> $$
> is **acyclic**.


> [!important] Theorem
> Given an LTS $G = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$, a level of choice function $\xi$ on $G$, and a strong bisimulation $\sim$ on $\mathcal{V}$, we have that 
> $s \sim s' \implies \xi(s) = \xi(s')$.

### Graph Splitting
---

Given an acyclic graph $G = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$ equipped with a level of choice function $\xi : \mathcal{V} \rightarrow \mathbb{N} \cup \{\infty\}$, we compute a split graph as follows. For any $\nu \in \mathcal{V}$, let:

> [!important] bounds
> $$
> \text{bounds}(\nu) = 
> \begin{cases} 
> \max\{\xi(\nu), \text{bounds}(\nu')\} \text{ for all } \nu' \in \nu^\bullet & \text{if } \nu^\bullet \neq \emptyset \\
> \xi(\nu) & \text{otherwise} 
> \end{cases}
> $$


> [!NOTE] 
> especially in final locations the post set is empty and also in locations which has no outgoing transitions, in such location the level of choice is 0

We define the split graph $G' = \langle \Sigma, \mathcal{V}', \mathcal{E}', \mathcal{V}'^0, \mathcal{V}'^F \rangle$ where:

> [!important] Split Graph
> - $\mathcal{V}' = \{(\nu, b) \mid \nu \in \mathcal{V} \land b \in \text{bounds}(\nu)\}$
> - $\mathcal{E}' = \{((\nu, b), e, (\nu', b')) \mid (\nu, e, \nu') \in \mathcal{E} \land b = \max\{b', \xi(\nu)\}\}$
> - $\mathcal{V}'^0 = \{(\nu, b) \in \mathcal{V}' \mid \nu \in \mathcal{V}^0\}$
> - $\mathcal{V}'^F = \{(\nu, b) \in \mathcal{V}' \mid \nu \in \mathcal{V}^F\}$

That is, ==we duplicate the states according to the **maximum levels of choice** that may be encountered in the future,== and update the edges so as to point to the matching copy. We extend $\xi$ to the split graph by putting $\xi((\nu, b)) = \xi(\nu)$. Intuitively, $G'$ ==accepts the same traces as $G$==, while ==ensuring that each state is either an effective choice== or not, independent of the future behavior.

### Subgraph Extraction
---
Experiments suggests that explanations are easier to grasp when only explanations of the same length are presented simultaneously. 

> [!important] Explanation Subgraph
> We therefore extract, from the split graph $\mathcal{G} = \langle \Sigma, \mathcal{V}', \mathcal{E}', (\mathcal{V}')^0, (\mathcal{V}')^F \rangle$, 
> for $l \in [\xi(\nu_0), \max \xi]$, 
> the graph $\mathcal{G}_l$ of explanations of length $l$ by restricting the LTS $\langle \Sigma, \mathcal{V}', \mathcal{E}'', (\mathcal{V}'')^0, (\mathcal{V}'')^F \rangle$ where:
> 
> $$
> \mathcal{V}'' = \{ (v, b) \in \mathcal{V}' \mid b \leq l \}
> $$
> $$
> \mathcal{E}'' = \mathcal{E}' \cap (\mathcal{V}'' \times \Sigma \times \mathcal{V}'')
> $$
> $$
> (\mathcal{V}'')^0 = \{ (v, b) \in (\mathcal{V}')^0 \mid b = l \}
> $$
> $$
> (\mathcal{V}'')^F = (\mathcal{V}')^F \cap \mathcal{V}''
> $$
> 

> [!NOTE]
> The transitions generated with the new states would include new transitions not derived from the original automata so we need to take the intersection.
> - Also in the diagram the subgraph has did not have $(s_0, 1)$, how could it skip that? = Maybe because  of the initial state condition which restricts the bound to be equal to l, by fixing different values of l we get different graphs

to the states that are reachable from $(\mathcal{V}'')^0$, and from which some state in $(\mathcal{V}'')^F$ is reachable. Notice that ==$\mathcal{G}_l$ is the empty graph when there is no explanation of length $l$==. 

- We then construct, for each (non-empty) **subgraph, an explanation by applying the [[standard determinization]]** (τ-elimination) algorithm based on subset construction to **"collapse" the non-pertinent parts of the graph.**
- By determinization we obtain the explanations, that **highlight the decisive events** for disjoint scenarios, with increasing complexity of the explanation.

> [!important] Theorem
> For each trace $w \in \Psi(G)$ there exists $l \in [\xi(\nu_0), \max \xi]$ such that $w \in \mathcal{G}_l$.

- This result means that any log-consistent violation is contained in some subgraph after **split** and **extraction**


### Compressing $\delta$ sequences and estimating time delays
---

- There could be sequence of **discretized time delays** whose 
- intermediate states are distinguished by the bisimulation.

Advantage of eliminating these sequence of time delays is -
- Construct a more concise explanation.
- Allows us to **quantitatively estimate the possible time delays** of the concrete runs that are summarized by the explanations

> [!important] Compressing 
> Given a sub-graph $\mathcal{G}_l = \langle \Sigma, \mathcal{V}, \mathcal{E}, \mathcal{V}^0, \mathcal{V}^F \rangle$, a $\delta^+$-sequence is an atomic sequence of transitions:
> $$
> \sigma = \nu_1 \xrightarrow{\delta} \nu_2 \xrightarrow{\delta} ... \xrightarrow{\delta} \nu_{n+1},
> $$
> that is,
> 1. 
> $$
> \forall i \in \{1, ..., n\} \ \forall e \in \Sigma \ \forall \nu' \in \mathcal{V}: (\nu_i \xrightarrow{e} \nu' \implies e = \delta \land \nu' = \nu_{i+1})
> $$
> such that 
> 2. $\nu_1 \xrightarrow{\delta} \nu_2$ is an ==effective choice transition==.
> 

As illustrated in **Figure 3**, we replace each maximal $\delta^+$-sequence $\sigma$ with a single transition $\nu_1 \xrightarrow{\delta} \nu_{n+1}$. ==The second condition requires the first transition of the sequence to be effective choice==, which ensures the ==information about effective choice states==, used in the sequel, to be ==preserved==.

![[Pasted image 20240918115706.png]]

For each state $s$ and clock $c$, 

> [!important] time delay
> there exist constants $\inf_c^s, \sup_c^s \in \mathbb{N} \cup \{\infty\}$ such that in $s$, $\inf_c^s \leq c \leq \sup_c^s$. 
> If $s'$ is a ==time successor== of $s$, then we can estimate the delay to be between:
> 
> $$
> \delta_{\inf} = \max_{c \in C}(\inf_c^{s'} - \sup_c^s) \quad \text{and} \quad \delta_{\sup} = \min_{c \in C}(\sup_c^{s'} - \inf_c^s).
> $$
> 
> In the case where $\delta_{\inf}$ is negative, it is set to $0$.


### Safe Alternatives
---

The construction of explanations is to ==highlight the events that contributed to the violation of a safety property==. 
Complementary to this information, and equally crucial for understanding how the property was violated, is the question, 
=="How could the outcome have been avoided?" Providing this information is the goal of *safe alternatives*.==

> [!important] Safe Alternative
> A transition $\nu \xrightarrow{e} \nu'$ of an LTS $\mathcal{G}_l$ is a safe alternative iff $\nu$ is an effective choice state and $\xi(\nu') \geq \xi(\nu)$.

Intuitively, given a choice state, a safe alternative is a transition that would have contributed to ==avoiding the violation by not decreasing the level of choice.==

### State Constraints
---

- Information about the states where some relevant event took place.

 In this section, let us assume the TA to be equipped with a function 
 $$\pi : L \to 2^\Pi$$ that ==labels each location with a set of atomic propositions==. 

A straightforward approach for displaying the states in the explanation would be to compute, for each ==aggregate state of the determinized graph consisting of a set ==$Q$ of locations, the disjunction of the invariants (resp. of the atomic propositions) of the locations in $L$. This would, however, lead to unreadably complex expressions.


> [!NOTE] 
> Aggregate state of the determinized graph consisting of a set of locations $Q$

Label each state $q = \{ \nu_1, \ldots, \nu_k \} \in Q$ returned by ==determinization==, with a [[convex predicate]] of the form 

> [!important] State constraints
> $\nu_1 \sqcup \cdots \sqcup \nu_k := \hat{C}(q) \land SP(q)$, where

> [!important] $\hat{C(q)}$
> - $\hat{C}(q)$ is the ==weakest convex clock constraint that is implied by the invariants== of the locations of all ==**effective choice states** in $q$.==

( $q$ is an amalgamation of states based on the effective choice transitions, it contains states which does not have effective transitions as well as states which has one. Given in the diagram in each level)

![[Pasted image 20240918130955.png]]

  It is straightforward to compute this clock constraint from the DBMs of the involved location invariants.

- Similarly, for the function $SP$ that ==aggregates, for a state $q$, atomic propositions of the states== in $q$, multiple definitions are possible. We settle for the 

> [!important] $SP(q)$
> - ==conjunction of the atomic propositions that hold in all **effective choice states** in $q$==. This set is therefore obtained as:
> 
> $$
> SP(q) = \bigcap_{\nu_i \in q: \nu_i \text{ is an effective choice state}} \bigcap_{\ell \in \nu_i} \pi(\ell)
> $$


# Implementation and Case Study
---

- Python based tool. 

It relies on **Kronos** for the composition of timed automata, **Minim** for the generation of the quotient graph, and **CADP** for reductions up to bisimulation.

- Dual Chamber [[Modeling and Verification of a Dual Chamber Implantable Pacemaker|implantable pacemaker model]], multicomponent system where ccomponents are timed automata communicating over channels.(UPPAL used)
- [[Tar Tar A Timed Automata Repair Tool|TarTar]] model used which is translated into the Kronos format.
- Contains 5 TA for the components of the pacemakers, 2 TA that model its environment(atrial and ventricular behavior). 
- We focus on the requirement that the time between two ventricular events never exceeds 1000ms.
- With modified parameters of the pacemaker so as to allow for unsafe behaviors.

Approach -

1. The first step is to generate the log observer, which consists of 8 locations and 60 transitions.

2. We invoke Kronos to compose the components, the safety property observer, and the log
observer.

3. We use Minim to compute the quotient graph with respect to strong time-abstracting
bisimulation.

4. The levels of choice and safe alternatives are computed.

5. We remove the states that are not consistent with the log or the property violation. The
difference in size is important because the observed behavior is only a small part of the
behavior of the model.

6. In this case study the effective choice states are not ambiguous, therefore splitting does not
change the graph. Similarly, the extracted sub-graph amounts to the full graph here.

7. Two maximal $\delta^+$-sequences of length 11 (resp. 6) are found, encompassing 10 (resp. 6)
effective choice transitions. After $\delta^+$ -compression, the quantitative time delays along the
abstract delay transitions (called “time_succ” in our implementation) are computed.

8. After determinization we obtain the explanation

### Comparison with [[Tar Tar A Timed Automata Repair Tool|TarTar]]
---

TarTar focuses on **fixing time delay parameters** in order to repair safety violations, and
proposes a **repair of the bounds on TURI**. Our approach is more general in the sense that it
does not restrict its attention to time delays. On the other hand, it does not propose a repair. In
particular, **our explanations are useful to explain failures caused by nondeterministic behavior**, or
when there are no admissible(allowed/permissible) repairs but one still wants to understand the causes of a violation.